{"version":3,"file":"jsonquery.js","sources":["../src/is.ts","../src/functions.ts","../src/compile.ts","../src/operators.ts","../src/regexps.ts","../src/parse.ts","../src/stringify.ts","../src/jsonquery.ts"],"sourcesContent":["export const isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const isObject = (value: unknown): value is object =>\n  value !== null && typeof value === 'object' && !isArray(value)\n\nexport const isString = (value: unknown): value is string => typeof value === 'string'\n\n// source: https://stackoverflow.com/a/77278013/1262753\nexport const isEqual = <T>(a: T, b: T): boolean => {\n  if (a === b) {\n    return true\n  }\n\n  const bothObject = a !== null && b !== null && typeof a === 'object' && typeof b === 'object'\n\n  return (\n    bothObject &&\n    Object.keys(a).length === Object.keys(b).length &&\n    Object.entries(a).every(([k, v]) => isEqual(v, b[k as keyof T]))\n  )\n}\n\nexport const getSafeProperty = (object: unknown, prop: string | number): unknown => {\n  const value = object?.[prop]\n  if (value === undefined) {\n    return undefined\n  }\n\n  // 1. do not allow getting props from the prototype (can be unsafe, like .constructor)\n  // 2. in case of an array, test if prop is an int\n  // 3. do not allow getting props from a string or number for example\n  if (\n    !Object.hasOwn(object as object, prop) ||\n    (Array.isArray(object) && !/^\\d+$/.test(prop as string)) ||\n    typeof object !== 'object'\n  ) {\n    throw new TypeError(`Unsupported property \"${prop}\"`)\n  }\n\n  return value\n}\n","import { compile } from './compile'\nimport { getSafeProperty, isArray, isEqual } from './is'\nimport type {\n  Entry,\n  FunctionBuilder,\n  FunctionBuildersMap,\n  Getter,\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryProperty\n} from './types'\n\nexport function buildFunction(fn: (...args: unknown[]) => unknown): FunctionBuilder {\n  return (...args: JSONQuery[]) => {\n    const compiledArgs = args.map((arg) => compile(arg))\n\n    const arg0 = compiledArgs[0]\n    const arg1 = compiledArgs[1]\n\n    return compiledArgs.length === 1\n      ? (data: unknown) => fn(arg0(data))\n      : compiledArgs.length === 2\n        ? (data: unknown) => fn(arg0(data), arg1(data))\n        : (data: unknown) => fn(...compiledArgs.map((arg) => arg(data)))\n  }\n}\n\nconst sortableTypes = { boolean: 0, number: 1, string: 2 }\nconst otherTypes = 3\n\nconst gt = (a: unknown, b: unknown) =>\n  typeof a === typeof b && (typeof a) in sortableTypes ? a > b : false\n\nconst gte = (a: unknown, b: unknown) => isEqual(a, b) || gt(a, b)\n\nconst lt = (a: unknown, b: unknown) =>\n  typeof a === typeof b && (typeof a) in sortableTypes ? a < b : false\n\nconst lte = (a: unknown, b: unknown) => isEqual(a, b) || lt(a, b)\n\nexport const functions: FunctionBuildersMap = {\n  pipe: (...entries: JSONQuery[]) => {\n    const _entries = entries.map((entry) => compile(entry))\n\n    return (data: unknown) => _entries.reduce((data, evaluator) => evaluator(data), data)\n  },\n\n  object: (query: JSONQueryObject) => {\n    const getters: Getter[] = Object.keys(query).map((key) => [key, compile(query[key])])\n\n    return (data: unknown) => {\n      const obj = {}\n      for (const [key, getter] of getters) {\n        obj[key] = getter(data)\n      }\n      return obj\n    }\n  },\n\n  array: (...items: JSONQuery[]) => {\n    const _items = items.map((entry: JSONQuery) => compile(entry))\n\n    return (data: unknown) => _items.map((item) => item(data))\n  },\n\n  get: (...path: JSONPath) => {\n    if (path.length === 0) {\n      return (data: unknown) => data ?? null\n    }\n\n    if (path.length === 1) {\n      const prop = path[0]\n      return (data: unknown) => getSafeProperty(data, prop) ?? null\n    }\n\n    return (data: unknown) => {\n      let value = data\n\n      for (const prop of path) {\n        value = getSafeProperty(value, prop)\n      }\n\n      return value ?? null\n    }\n  },\n\n  map: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: T[]) => data.map(_callback)\n  },\n\n  mapObject: <T, U>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updated = _callback({ key, value: data[key] }) as Entry<U>\n        output[updated.key] = updated.value\n      }\n      return output\n    }\n  },\n\n  mapKeys: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updatedKey = _callback(key) as string\n        output[updatedKey] = data[key]\n      }\n      return output\n    }\n  },\n\n  mapValues: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        output[key] = _callback(data[key])\n      }\n      return output\n    }\n  },\n\n  filter: <T>(predicate: JSONQuery) => {\n    const _predicate = compile(predicate)\n\n    return (data: T[]) => data.filter((item) => truthy(_predicate(item)))\n  },\n\n  sort: <T>(path: JSONQueryProperty = ['get'], direction?: 'asc' | 'desc') => {\n    const getter = compile(path)\n    const sign = direction === 'desc' ? -1 : 1\n\n    function compare(itemA: unknown, itemB: unknown) {\n      const a = getter(itemA)\n      const b = getter(itemB)\n\n      // Order mixed types\n      if (typeof a !== typeof b) {\n        const aIndex = sortableTypes[typeof a] ?? otherTypes\n        const bIndex = sortableTypes[typeof b] ?? otherTypes\n\n        return aIndex > bIndex ? sign : aIndex < bIndex ? -sign : 0\n      }\n\n      // Order two numbers, two strings, or two booleans\n      if ((typeof a) in sortableTypes) {\n        return a > b ? sign : a < b ? -sign : 0\n      }\n\n      // Leave arrays, objects, and unknown types ordered as is\n      return 0\n    }\n\n    return (data: T[]) => data.slice().sort(compare)\n  },\n\n  reverse:\n    <T>() =>\n    (data: T[]) =>\n      data.toReversed(),\n\n  pick: (...properties: JSONQueryProperty[]) => {\n    const getters = properties.map(\n      ([_get, ...path]) => [path[path.length - 1], functions.get(...path)] as Getter\n    )\n\n    const _pick = (object: Record<string, unknown>, getters: Getter[]): unknown => {\n      const out = {}\n      for (const [key, getter] of getters) {\n        out[key] = getter(object)\n      }\n      return out\n    }\n\n    return (data: Record<string, unknown>): unknown => {\n      if (isArray(data)) {\n        return data.map((item: Record<string, unknown>) => _pick(item, getters))\n      }\n\n      return _pick(data, getters)\n    }\n  },\n\n  groupBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (res[value]) {\n          res[value].push(item)\n        } else {\n          res[value] = [item]\n        }\n      }\n\n      return res\n    }\n  },\n\n  keyBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (!(value in res)) {\n          res[value] = item\n        }\n      }\n\n      return res\n    }\n  },\n\n  flatten: () => (data: unknown[]) => data.flat(),\n\n  join:\n    <T>(separator = '') =>\n    (data: T[]) =>\n      data.join(separator),\n\n  split: buildFunction((text: string, separator?: string) =>\n    separator !== undefined ? text.split(separator) : text.trim().split(/\\s+/)\n  ),\n\n  substring: buildFunction((text: string, start: number, end?: number) =>\n    text.slice(Math.max(start, 0), end)\n  ),\n\n  uniq:\n    () =>\n    <T>(data: T[]) => {\n      const res: T[] = []\n\n      for (const item of data) {\n        if (res.findIndex((resItem) => isEqual(resItem, item)) === -1) {\n          res.push(item)\n        }\n      }\n\n      return res\n    },\n\n  uniqBy:\n    <T>(path: JSONQueryProperty) =>\n    (data: T[]): T[] =>\n      Object.values(functions.keyBy(path)(data)),\n\n  limit:\n    (count: number) =>\n    <T>(data: T[]) =>\n      data.slice(0, Math.max(count, 0)),\n\n  size:\n    () =>\n    <T>(data: T[]) =>\n      data.length,\n\n  keys: () => Object.keys,\n  values: () => Object.values,\n\n  prod: () => (data: number[]) => reduce(data, (a, b) => a * b),\n\n  sum: () => (data: number[]) =>\n    isArray(data) ? data.reduce((a, b) => a + b, 0) : throwArrayExpected(),\n\n  average: () => (data: number[]) =>\n    isArray(data)\n      ? data.length > 0\n        ? data.reduce((a, b) => a + b) / data.length\n        : null\n      : throwArrayExpected(),\n\n  min: () => (data: number[]) => reduce(data, (a, b) => Math.min(a, b)),\n  max: () => (data: number[]) => reduce(data, (a, b) => Math.max(a, b)),\n\n  and: buildFunction((...data: unknown[]) => reduce(data, (a, b) => !!(a && b))),\n  or: buildFunction((...data: unknown[]) => reduce(data, (a, b) => !!(a || b))),\n  not: buildFunction((a: unknown) => !a),\n\n  exists: (queryGet: JSONQueryFunction) => {\n    const parentPath = queryGet.slice(1)\n    const key = parentPath.pop()\n    const getter = functions.get(...parentPath)\n\n    return (data: unknown) => {\n      const parent = getter(data)\n      return !!parent && Object.hasOwnProperty.call(parent, key)\n    }\n  },\n  if: (condition: JSONQuery, valueIfTrue: JSONQuery, valueIfFalse: JSONQuery) => {\n    const _condition = compile(condition)\n    const _valueIfTrue = compile(valueIfTrue)\n    const _valueIfFalse = compile(valueIfFalse)\n\n    return (data: unknown) => (truthy(_condition(data)) ? _valueIfTrue(data) : _valueIfFalse(data))\n  },\n  in: (value: JSONQuery, values: JSONQuery) => {\n    const getValue = compile(value)\n    const getValues = compile(values)\n\n    return (data: unknown) => {\n      const _value = getValue(data)\n      const _values = getValues(data) as unknown[]\n\n      return _values.findIndex((item) => isEqual(item, _value)) !== -1\n    }\n  },\n  'not in': (value: JSONQuery, values: JSONQuery) => {\n    const _in = functions.in(value, values)\n\n    return (data: unknown) => !_in(data)\n  },\n  regex: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, options)\n    const getter = compile(path)\n\n    return (data: unknown) => regex.test(getter(data) as string)\n  },\n\n  match: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, options)\n    const getter = compile(path)\n\n    return (data: unknown) => {\n      const result = (getter(data) as string).match(regex)\n      return result ? matchToJSON(result) : null\n    }\n  },\n\n  matchAll: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, `${options ?? ''}g`)\n    const getter = compile(path)\n\n    return (data: unknown) => Array.from((getter(data) as string).matchAll(regex)).map(matchToJSON)\n  },\n\n  eq: buildFunction(isEqual),\n  gt: buildFunction(gt),\n  gte: buildFunction(gte),\n  lt: buildFunction(lt),\n  lte: buildFunction(lte),\n  ne: buildFunction((a, b) => !isEqual(a, b)),\n\n  add: buildFunction((a: number, b: number) => a + b),\n  subtract: buildFunction((a: number, b: number) => a - b),\n  multiply: buildFunction((a: number, b: number) => a * b),\n  divide: buildFunction((a: number, b: number) => a / b),\n  mod: buildFunction((a: number, b: number) => a % b),\n  pow: buildFunction((a: number, b: number) => a ** b),\n\n  abs: buildFunction(Math.abs),\n  round: buildFunction((value: number, digits = 0) => {\n    const num = Math.round(Number(`${value}e${digits}`))\n    return Number(`${num}e${-digits}`)\n  }),\n\n  number: buildFunction((text: string) => {\n    const num = Number(text)\n    return Number.isNaN(Number(text)) ? null : num\n  }),\n  string: buildFunction(String)\n}\n\nconst truthy = (x: unknown) => x !== null && x !== 0 && x !== false\n\nconst reduce = <T>(data: T[], callback: (previousValue: T, currentValue: T) => T): T => {\n  if (!isArray(data)) {\n    throwArrayExpected()\n  }\n\n  if (data.length === 0) {\n    return null\n  }\n\n  return data.reduce(callback)\n}\n\nconst matchToJSON = (result: RegExpMatchArray) => {\n  const [value, ...groups] = result\n  const namedGroups = result.groups\n\n  return groups.length\n    ? namedGroups\n      ? { value, groups, namedGroups }\n      : { value, groups }\n    : { value }\n}\n\nconst throwArrayExpected = () => {\n  throwTypeError('Array expected')\n}\n\nexport const throwTypeError = (message: string) => {\n  throw new TypeError(message)\n}\n","import { functions, throwTypeError } from './functions'\nimport { isArray, isObject } from './is'\nimport type {\n  Fun,\n  FunctionBuildersMap,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction\n} from './types'\n\nconst functionsStack: FunctionBuildersMap[] = []\n\nexport function compile(query: JSONQuery, options?: JSONQueryCompileOptions): Fun {\n  functionsStack.unshift({ ...functions, ...functionsStack[0], ...options?.functions })\n\n  try {\n    const exec = isArray(query)\n      ? compileFunction(query as JSONQueryFunction, functionsStack[0]) // function\n      : isObject(query)\n        ? throwTypeError(\n            `Function notation [\"object\", {...}] expected but got ${JSON.stringify(query)}`\n          )\n        : () => query // primitive value (string, number, boolean, null)\n\n    // create a wrapper function which can attach a stack to the error\n    return (data) => {\n      try {\n        return exec(data)\n      } catch (err) {\n        // attach a stack to the error\n        err.jsonquery = [{ data, query }, ...(err.jsonquery ?? [])]\n\n        throw err\n      }\n    }\n  } finally {\n    functionsStack.shift()\n  }\n}\n\nfunction compileFunction(query: JSONQueryFunction, functions: FunctionBuildersMap) {\n  const [fnName, ...args] = query\n\n  const fnBuilder = functions[fnName]\n  if (!fnBuilder) {\n    throwTypeError(`Unknown function '${fnName}'`)\n  }\n\n  return fnBuilder(...args)\n}\n","import { isArray } from './is'\nimport type { CustomOperator, OperatorGroup } from './types'\n\n// operator precedence from highest to lowest\nexport const operators: OperatorGroup[] = [\n  { pow: '^' },\n  { multiply: '*', divide: '/', mod: '%' },\n  { add: '+', subtract: '-' },\n  { gt: '>', gte: '>=', lt: '<', lte: '<=', in: 'in', 'not in': 'not in' },\n  { eq: '==', ne: '!=' },\n  { and: 'and' },\n  { or: 'or' },\n  { pipe: '|' }\n]\n\nexport const varargOperators = ['|', 'and', 'or']\nexport const leftAssociativeOperators = ['|', 'and', 'or', '*', '/', '%', '+', '-']\n\nexport function extendOperators(operators: OperatorGroup[], customOperators: CustomOperator[]) {\n  // backward compatibility error with v4 where `operators` was an object\n  if (!isArray(customOperators)) {\n    throw new Error('Invalid custom operators')\n  }\n\n  return customOperators.reduce(extendOperator, operators)\n}\n\nfunction extendOperator(\n  operators: OperatorGroup[],\n  // @ts-expect-error Inside the function we will check whether at, below, and above are defined\n  { name, op, at, after, before }: CustomOperator\n): OperatorGroup[] {\n  if (at) {\n    return operators.map((group) => {\n      return Object.values(group).includes(at) ? { ...group, [name]: op } : group\n    })\n  }\n\n  const searchOp = after ?? before\n  const index = operators.findIndex((group) => Object.values(group).includes(searchOp))\n  if (index !== -1) {\n    return operators.toSpliced(index + (after ? 1 : 0), 0, { [name]: op })\n  }\n\n  throw new Error('Invalid custom operator')\n}\n","export const unquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nexport const startsWithUnquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*/\nexport const startsWithStringRegex = /^\"(?:[^\"\\\\]|\\\\.)*\"/ // https://stackoverflow.com/a/249937/1262753\nexport const startsWithNumberRegex = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/ // https://stackoverflow.com/a/13340826/1262753\nexport const startsWithIntRegex = /^(0|[1-9][0-9]*)/\nexport const startsWithKeywordRegex = /^(true|false|null)/\nexport const startsWithWhitespaceRegex = /^[ \\n\\t\\r]+/\n","import { extendOperators, leftAssociativeOperators, operators, varargOperators } from './operators'\nimport {\n  startsWithIntRegex,\n  startsWithKeywordRegex,\n  startsWithNumberRegex,\n  startsWithStringRegex,\n  startsWithUnquotedPropertyRegex,\n  startsWithWhitespaceRegex\n} from './regexps'\nimport type { JSONQuery, JSONQueryParseOptions, OperatorGroup } from './types'\n\n/**\n * Parse a string containing a JSON Query into JSON.\n *\n * Example:\n *\n *     const textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *     const jsonQuery = parse(textQuery)\n *     // jsonQuery = [\n *     //    'pipe',\n *     //    ['get', 'friends'],\n *     //    ['filter', ['eq', ['get', 'city'], 'New York']],\n *     //    ['sort', ['get', 'age']],\n *     //    ['pick', ['get', 'name'], ['get', 'age']]\n *     //  ]\n */\nexport function parse(query: string, options?: JSONQueryParseOptions): JSONQuery {\n  const customOperators = options?.operators ?? []\n  const allOperators = extendOperators(operators, customOperators)\n  const allOperatorsMap = Object.assign({}, ...allOperators)\n  const allVarargOperators = varargOperators.concat(\n    customOperators.filter((op) => op.vararg).map((op) => op.op)\n  )\n  const allLeftAssociativeOperators = leftAssociativeOperators.concat(\n    customOperators.filter((op) => op.leftAssociative).map((op) => op.op)\n  )\n\n  const parseOperator = (precedenceLevel = allOperators.length - 1) => {\n    const currentOperators = allOperators[precedenceLevel]\n    if (!currentOperators) {\n      return parseParenthesis()\n    }\n\n    const leftParenthesis = query[i] === '('\n    let left = parseOperator(precedenceLevel - 1)\n\n    while (true) {\n      skipWhitespace()\n\n      if (query[i] === '.' && 'pipe' in currentOperators) {\n        // an implicitly piped property like \"fn().prop\"\n        const right = parseProperty()\n        left = left[0] === 'pipe' ? [...left, right] : ['pipe', left, right]\n        continue\n      }\n\n      const start = i\n      const name = parseOperatorName(currentOperators)\n      if (!name) {\n        break\n      }\n\n      const right = parseOperator(precedenceLevel - 1)\n\n      const childName = left[0]\n      const chained = name === childName && !leftParenthesis\n      if (chained && !allLeftAssociativeOperators.includes(allOperatorsMap[name])) {\n        i = start\n        break\n      }\n\n      left =\n        chained && allVarargOperators.includes(allOperatorsMap[name])\n          ? [...left, right]\n          : [name, left, right]\n    }\n\n    return left\n  }\n\n  const parseOperatorName = (currentOperators: OperatorGroup): string | undefined => {\n    // we sort the operators from longest to shortest, so we first handle \"<=\" and next \"<\"\n    const sortedOperatorNames = Object.keys(currentOperators).sort((a, b) => b.length - a.length)\n\n    for (const name of sortedOperatorNames) {\n      const op = currentOperators[name]\n      if (query.substring(i, i + op.length) === op) {\n        i += op.length\n\n        skipWhitespace()\n\n        return name\n      }\n    }\n\n    return undefined\n  }\n\n  const parseParenthesis = () => {\n    skipWhitespace()\n\n    if (query[i] === '(') {\n      i++\n      const inner = parseOperator()\n      eatChar(')')\n      return inner\n    }\n\n    return parseProperty()\n  }\n\n  const parseProperty = () => {\n    if (query[i] === '.') {\n      const props = []\n\n      while (query[i] === '.') {\n        i++\n\n        props.push(\n          parseString() ??\n            parseUnquotedString() ??\n            parseInteger() ??\n            throwSyntaxError('Property expected')\n        )\n\n        skipWhitespace()\n      }\n\n      return ['get', ...props]\n    }\n\n    return parseFunction()\n  }\n\n  const parseFunction = () => {\n    const start = i\n    const name = parseUnquotedString()\n    skipWhitespace()\n    if (!name || query[i] !== '(') {\n      i = start\n      return parseObject()\n    }\n    i++\n\n    skipWhitespace()\n\n    const args = query[i] !== ')' ? [parseOperator()] : []\n    while (i < query.length && query[i] !== ')') {\n      skipWhitespace()\n      eatChar(',')\n      args.push(parseOperator())\n    }\n\n    eatChar(')')\n\n    return [name, ...args]\n  }\n\n  const parseObject = () => {\n    if (query[i] === '{') {\n      i++\n      skipWhitespace()\n\n      const object = {}\n      let first = true\n      while (i < query.length && query[i] !== '}') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        const key =\n          parseString() ??\n          parseUnquotedString() ??\n          parseInteger() ??\n          throwSyntaxError('Key expected')\n\n        skipWhitespace()\n        eatChar(':')\n\n        object[key] = parseOperator()\n      }\n\n      eatChar('}')\n\n      return ['object', object]\n    }\n\n    return parseArray()\n  }\n\n  const parseArray = () => {\n    if (query[i] === '[') {\n      i++\n      skipWhitespace()\n\n      const array = []\n\n      let first = true\n      while (i < query.length && query[i] !== ']') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        array.push(parseOperator())\n      }\n\n      eatChar(']')\n\n      return ['array', ...array]\n    }\n\n    return parseString() ?? parseNumber() ?? parseKeyword()\n  }\n\n  const parseString = () => parseRegex(startsWithStringRegex, JSON.parse)\n\n  const parseUnquotedString = () => parseRegex(startsWithUnquotedPropertyRegex, (text) => text)\n\n  const parseNumber = () => parseRegex(startsWithNumberRegex, JSON.parse)\n\n  const parseInteger = () => parseRegex(startsWithIntRegex, JSON.parse)\n\n  const parseKeyword = () => {\n    const keyword = parseRegex(startsWithKeywordRegex, JSON.parse)\n    if (keyword !== undefined) {\n      return keyword\n    }\n\n    // end of the parsing chain\n    throwSyntaxError('Value expected')\n  }\n\n  const parseEnd = () => {\n    skipWhitespace()\n\n    if (i < query.length) {\n      throwSyntaxError(`Unexpected part '${query.substring(i)}'`)\n    }\n  }\n\n  const parseRegex = <T = string>(regex: RegExp, callback: (match: string) => T): T | undefined => {\n    const match = query.substring(i).match(regex)\n    if (match) {\n      i += match[0].length\n      return callback(match[0])\n    }\n  }\n\n  const skipWhitespace = () => parseRegex(startsWithWhitespaceRegex, (text) => text)\n\n  const eatChar = (char: string) => {\n    if (query[i] !== char) {\n      throwSyntaxError(`Character '${char}' expected`)\n    }\n    i++\n  }\n\n  const throwSyntaxError = (message: string, pos = i) => {\n    throw new SyntaxError(`${message} (pos: ${pos})`)\n  }\n\n  let i = 0\n  const output = parseOperator()\n  parseEnd()\n\n  return output\n}\n","import { isArray } from './is'\nimport { extendOperators, leftAssociativeOperators, operators } from './operators'\nimport { unquotedPropertyRegex } from './regexps'\nimport type {\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryStringifyOptions\n} from './types'\n\nconst DEFAULT_MAX_LINE_LENGTH = 40\nconst DEFAULT_INDENTATION = '  '\n\n/**\n * Stringify a JSON Query into a readable, human friendly text syntax.\n *\n * Example:\n *\n *     const jsonQuery = [\n *         ['get', 'friends'],\n *         ['filter', ['eq', ['get', 'city'], 'New York']],\n *         ['sort', ['get', 'age']],\n *         ['pick', ['get', 'name'], ['get', 'age']]\n *       ]\n *     const textQuery = stringify(jsonQuery)\n *     // textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *\n * @param query The JSON Query to be stringified\n * @param {Object} [options] An object which can have the following options:\n *                 `maxLineLength` Optional maximum line length. When the query exceeds this maximum,\n *                                 It will be formatted over multiple lines. Default value: 40.\n *                 `indentation`   Optional indentation. Defaults to a string with two spaces: '  '.\n */\nexport const stringify = (query: JSONQuery, options?: JSONQueryStringifyOptions) => {\n  const space = options?.indentation ?? DEFAULT_INDENTATION\n  const customOperators = options?.operators ?? []\n  const allOperators = extendOperators(operators, customOperators)\n  const allOperatorsMap = Object.assign({}, ...allOperators)\n  const allLeftAssociativeOperators = leftAssociativeOperators.concat(\n    customOperators.filter((op) => op.leftAssociative).map((op) => op.op)\n  )\n\n  const _stringify = (query: JSONQuery, indent: string, parenthesis = false) =>\n    isArray(query)\n      ? stringifyFunction(query as JSONQueryFunction, indent, parenthesis)\n      : JSON.stringify(query) // value (string, number, boolean, null)\n\n  const stringifyFunction = (query: JSONQueryFunction, indent: string, parenthesis: boolean) => {\n    const [name, ...args] = query\n\n    if (name === 'get' && args.length > 0) {\n      return stringifyPath(args as JSONPath)\n    }\n\n    if (name === 'object') {\n      return stringifyObject(args[0] as JSONQueryObject, indent)\n    }\n\n    if (name === 'array') {\n      const argsStr = args.map((arg) => _stringify(arg, indent))\n      return join(\n        argsStr,\n        ['[', ', ', ']'],\n        [`[\\n${indent + space}`, `,\\n${indent + space}`, `\\n${indent}]`]\n      )\n    }\n\n    // operator like \".age >= 18\"\n    const op = allOperatorsMap[name]\n    if (op) {\n      const start = parenthesis ? '(' : ''\n      const end = parenthesis ? ')' : ''\n\n      const argsStr = args.map((arg, index) => {\n        const childName = arg?.[0]\n        const precedence = allOperators.findIndex((group) => name in group)\n        const childPrecedence = allOperators.findIndex((group) => childName in group)\n        const childParenthesis =\n          precedence < childPrecedence ||\n          (precedence === childPrecedence && index > 0) ||\n          (name === childName && !allLeftAssociativeOperators.includes(op))\n\n        return _stringify(arg, indent + space, childParenthesis)\n      })\n\n      return join(argsStr, [start, ` ${op} `, end], [start, `\\n${indent + space}${op} `, end])\n    }\n\n    // regular function like \"sort(.age)\"\n    const childIndent = args.length === 1 ? indent : indent + space\n    const argsStr = args.map((arg) => _stringify(arg, childIndent))\n    return join(\n      argsStr,\n      [`${name}(`, ', ', ')'],\n      args.length === 1\n        ? [`${name}(`, `,\\n${indent}`, ')']\n        : [`${name}(\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent})`]\n    )\n  }\n\n  const stringifyObject = (query: JSONQueryObject, indent: string) => {\n    const childIndent = indent + space\n    const entries = Object.entries(query).map(([key, value]) => {\n      return `${stringifyProperty(key)}: ${_stringify(value, childIndent)}`\n    })\n\n    return join(\n      entries,\n      ['{ ', ', ', ' }'],\n      [`{\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent}}`]\n    )\n  }\n\n  const stringifyPath = (path: JSONPath): string =>\n    path.map((prop) => `.${stringifyProperty(prop)}`).join('')\n\n  const stringifyProperty = (prop: string): string =>\n    unquotedPropertyRegex.test(prop) ? prop : JSON.stringify(prop)\n\n  type JoinDefinition = [start: string, separator: string, end: string]\n\n  const join = (\n    items: string[],\n    [compactStart, compactSeparator, compactEnd]: JoinDefinition,\n    [formatStart, formatSeparator, formatEnd]: JoinDefinition\n  ): string => {\n    const compactLength =\n      compactStart.length +\n      items.reduce((sum: number, item: string) => sum + item.length + compactSeparator.length, 0) -\n      compactSeparator.length +\n      compactEnd.length\n\n    return compactLength <= (options?.maxLineLength ?? DEFAULT_MAX_LINE_LENGTH)\n      ? compactStart + items.join(compactSeparator) + compactEnd\n      : formatStart + items.join(formatSeparator) + formatEnd\n  }\n\n  return _stringify(query, '')\n}\n","import { compile } from './compile'\nimport { isString } from './is'\nimport { parse } from './parse'\nimport type { JSONQuery, JSONQueryOptions } from './types'\n\nexport function jsonquery(\n  data: unknown,\n  query: string | JSONQuery,\n  options?: JSONQueryOptions\n): unknown {\n  return compile(isString(query) ? parse(query, options) : query, options)(data)\n}\n\nexport { compile } from './compile'\nexport { stringify } from './stringify'\nexport { parse } from './parse'\nexport { buildFunction } from './functions'\n\nexport type {\n  CustomOperator,\n  Fun,\n  FunctionBuilder,\n  FunctionBuildersMap,\n  JSONPath,\n  JSONProperty,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryOptions,\n  JSONQueryParseOptions,\n  JSONQueryPrimitive,\n  JSONQueryProperty,\n  JSONQueryPipe,\n  JSONQueryStringifyOptions\n} from './types'\n"],"names":["isArray","value","isObject","isString","isEqual","a","b","k","v","getSafeProperty","object","prop","buildFunction","fn","args","compiledArgs","arg","compile","arg0","arg1","data","sortableTypes","otherTypes","gt","gte","lt","lte","functions","entries","_entries","entry","evaluator","query","getters","key","obj","getter","items","_items","item","path","callback","_callback","output","updated","updatedKey","predicate","_predicate","truthy","direction","sign","compare","itemA","itemB","aIndex","bIndex","properties","_get","_pick","out","res","separator","text","start","end","resItem","count","reduce","throwArrayExpected","queryGet","parentPath","parent","condition","valueIfTrue","valueIfFalse","_condition","_valueIfTrue","_valueIfFalse","values","getValue","getValues","_value","_in","expression","options","regex","result","matchToJSON","digits","num","x","groups","namedGroups","throwTypeError","message","functionsStack","exec","compileFunction","err","fnName","fnBuilder","operators","varargOperators","leftAssociativeOperators","extendOperators","customOperators","extendOperator","name","op","at","after","before","group","searchOp","index","unquotedPropertyRegex","startsWithUnquotedPropertyRegex","startsWithStringRegex","startsWithNumberRegex","startsWithIntRegex","startsWithKeywordRegex","startsWithWhitespaceRegex","parse","allOperators","allOperatorsMap","allVarargOperators","allLeftAssociativeOperators","parseOperator","precedenceLevel","currentOperators","parseParenthesis","leftParenthesis","left","skipWhitespace","right","parseProperty","parseOperatorName","childName","chained","sortedOperatorNames","inner","eatChar","props","parseString","parseUnquotedString","parseInteger","throwSyntaxError","parseFunction","parseObject","first","parseArray","array","parseNumber","parseKeyword","parseRegex","keyword","parseEnd","match","char","pos","DEFAULT_MAX_LINE_LENGTH","DEFAULT_INDENTATION","stringify","space","_stringify","indent","parenthesis","stringifyFunction","stringifyPath","stringifyObject","argsStr","join","precedence","childPrecedence","childParenthesis","childIndent","stringifyProperty","compactStart","compactSeparator","compactEnd","formatStart","formatSeparator","formatEnd","sum","jsonquery"],"mappings":"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"}